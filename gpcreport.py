# Copyright (c) 2015, Qiurui He
# Department of Engineering, University of Cambridge

import numpy as np
import pylatex as pl
import pylatex.utils as ut
import os

class GPCReport(object):
    """
    AutoGPC data analysis report.
    """

    def __init__(self, root='./latex', paper='a4paper', history=None):
        self.root = root
        self.doc = pl.Document()

        self.makePreamble(paper=paper)
        self.makeDataSummary(search_history=history) # Note: history[0] is NoneKernel
        self.makeMostSeparableDimensionSection(search_history=history)
        if len(history) > 2:
            self.makeNextSeparableDimensionSection(search_history=history)


    def makePreamble(self, paper='a4paper'):
        doc = self.doc

        doc.packages.append(pl.Package('geometry', options=['a4paper', 'margin=1.5in']))
        doc.packages.append(pl.Package('hyperref'))

        doc.preamble.append(pl.Command('title', 'AutoGPC Data Analysis Report'))
        doc.preamble.append(pl.Command('author', 'Automatic Statistician'))
        doc.preamble.append(pl.Command('date', ut.NoEscape(r'\today')))
        doc.append(ut.NoEscape(r'\maketitle'))

        doc.append(r'This report is automatically generated by the AutoGPC. For more information, please visit ')
        doc.append(pl.Command('url', 'https://github.com/charles92/autogpc'))
        doc.append(r'.')


    def makeDataSummary(self, search_history=None):
        assert isinstance(search_history, list) and len(search_history) > 1, \
            'search_history must be a list containing >=2 GPCKernel instances'
        kern = search_history[1]
        doc = self.doc
        data = kern.data
        dataShape = data.getDataShape()

        imgName = 'data'
        imgFormat = '.eps' if data.getDim() != 3 else '.png'
        imgOutName = imgName + imgFormat
        kern.draw(os.path.join(self.root, imgName), draw_posterior=False)

        with doc.create(pl.Section("The Dataset")):
            s = r"The training dataset contains {0} data points".format(data.getNum())
            s = s + r" which span {0} dimensions. ".format(data.getDim())
            for dim in xrange(data.getDim()):
                s = s + r"In dimension ``{0}'', ".format(data.XLabel[dim])
                s = s + r"the data has a minimum of {0:.2f} ".format(dataShape['x_min'][dim])
                s = s + r"and a maximum of {0:.2f}; ".format(dataShape['x_max'][dim])
                s = s + r"the standard deviation is {0:.2f}.".format(dataShape['x_sd'][dim])

            doc.append(ut.NoEscape(s))

            with doc.create(pl.Figure(position='h!')) as fig:
                fig.add_image(imgOutName)
                fig.add_caption(r"The input dataset.")


    def makeMostSeparableDimensionSection(self, search_history=None):
        assert isinstance(search_history, list) and len(search_history) > 1, \
            'search_history must be a list containing >=2 GPCKernel instances'
        kern = search_history[1]
        doc = self.doc
        data = kern.data
        dataShape = data.getDataShape()

        imgName = 'separable1'
        imgFormat = '.eps' if data.getDim() != 3 else '.png'
        imgOutName = imgName + imgFormat
        kern.draw(os.path.join(self.root, imgName), active_dims_only=True)

        separableDim = kern.getActiveDims()[0]
        separableDimLabel = data.XLabel[separableDim]
        wrongPts = kern.misclassifiedPoints()
        errorRate = wrongPts['X'].shape[0] / float(data.getNum()) * 100

        with doc.create(pl.Section("The Most Separable Dimension")):
            s = r"The dataset is most separable in the ``{0}'' dimension, ".format(separableDimLabel)
            s = s + r"as shown in the figure. "
            s = s + r"The training error rate is {0:.1f}\%.".format(errorRate)

            doc.append(ut.NoEscape(s))

            with doc.create(pl.Figure(position='h!')) as fig:
                fig.add_image(imgOutName)
                caption_str = r"The most separable dimension is ``{0}''.".format(separableDimLabel)
                fig.add_caption(ut.NoEscape(caption_str))


    def makeNextSeparableDimensionSection(self, search_history=None):
        assert isinstance(search_history, list) and len(search_history) > 2, \
            'search_history must be a list containing >=3 GPCKernel instances'
        kern = search_history[2]
        doc = self.doc
        data = kern.data
        dataShape = data.getDataShape()

        imgName = 'separable2'
        imgFormat = '.eps' if data.getDim() != 3 else '.png'
        imgOutName = imgName + imgFormat
        kern.draw(os.path.join(self.root, imgName), active_dims_only=True)

        prevKern = search_history[1]
        prevDim = prevKern.getActiveDims()[0]
        prevDimLabel = data.XLabel[prevDim]
        wrongPts = prevKern.misclassifiedPoints()
        prevErrorRate = wrongPts['X'].shape[0] / float(data.getNum()) * 100

        thisDim = (set(kern.getActiveDims()) - set([prevDim])).pop()
        thisDimLabel = data.XLabel[thisDim]
        wrongPts = kern.misclassifiedPoints()
        thisErrorRate = wrongPts['X'].shape[0] / float(data.getNum()) * 100

        diffErrorRate = prevErrorRate - thisErrorRate

        with doc.create(pl.Section("The Next Separable Dimension")):
            s = r"The classification performance can be improved by incorporating the ``{0}'' variable in addition to the ``{1}'' variable. ".format(thisDimLabel, prevDimLabel)
            s = s + r"This reduces the training error rate by {0:.1f}\% to {1:.1f}\%. ".format(diffErrorRate, thisErrorRate)
            s = s + r"The result is shown in the figure below, with predictive posterior probabilities. "

            doc.append(ut.NoEscape(s))

            with doc.create(pl.Figure(position='h!')) as fig:
                fig.add_image(imgOutName)
                caption_str = r"Trained classifier with two dimensions: ``{0}'' and ``{1}''.".format(prevDimLabel, thisDimLabel)
                fig.add_caption(ut.NoEscape(caption_str))


    def export(self, filename=None):
        if filename is None:
            filename = 'report'
        self.doc.generate_pdf(os.path.join(self.root, filename))
